DP란 무엇인가?
문제에 대한 정답이 될 가능성이 있는 모든 해결책을 "체계적"이고 "효율적"으로 탐색하는 풀이법

1. 크고 복잡한 문제를 작은 문제로 나눈다.(subproblem - 하위문제)
2. 하위 문제의 답을 계산한다.
 - 중복 계산해야 하는 하위 문제가 있다. (overlapping subproblem - 중복 하위 문제)
 - 한 번 계산한 결과는 메모레이 저장하여 재계산 하지 않도록 한다. => 속도 향상 (memoization, dp table)
3. 하위 문제에 대한 답을 통해 원래 문제에 대한 답을 계산한다. (optimal substructure - 최적 부분 구조)
 - 최적 부분 구조 : 하위 부분 문제에서 구한 최적의 답이 합쳐진 큰 문제의 최적의 답을 구할 수 있는 구조


예를들어 피모나치 수열을 생각해보자.

1 1 2 3 5 8 13 21 34 55 .....

첫번째 두번째 값을 합하면 3번째 합이 나온다.

10번째에는 무슨 값이 오는가?

접근방법 -> 완전탐색(재귀)
(1) 크고 복잡한 문제를 하위 문제로 나눈다.
(2) 하위 문제에 대한 답을 계산한다.
(3) 하위 문제에 대한 답으로 원래 문제에 대한 답을 계산한다.

n번째 값을 구하고 싶으면 아래와 같이 함수를 만들 수 있다.
def fibo(n):
    if n == 1 or n == 2:
        return 1
    return fibo(n-1) + fibo(n-2)

위 함수를 계산하다보면 중복되는 함수가 발생하게 된다.
그렇기 때문에 매우 비효율적이다.

시간복잡도를 계산해보면 O(2^n)이 나온다.


접근방법 -> 완전탐색(재귀) => DP를 이용해보자
(1) 크고 복잡한 문제를 하위 문제로 나눈다.
(2) 하위 문제에 대한 답을 계산한다.
 - overlapping subproblem - 중복된 하위 문제가 발생하였을때
 - memoization - 계산 결과를 저장하여 중복된 문제에 사용한다.
(3) 하위 문제에 대한 답으로 원래 문제에 대한 답을 계산한다.

메모리에 있는 값을 가져다 쓸 수 있기 때문에 재귀함수의 왼쪽 부분만 실행하면 오른쪽은 메모리에 있는
데이터를 가져다 쓸 수 있다.

그렇기 때문에 시간복잡도가 O(n)으로 낮아진다.

memo = {}

def fibo(n):
    if n == 1 or n == 2:
        return 1
    if n not in memo:
        memo[n] = fibo(n-1) + fibo(n-2)
    return memo[n]



DP 에는 2가지 방법이 있다.
1. TOP-DOWN
2. BOTTOM-UP


1. TOP-DOWN

memo = {}
def fibo(n):
    if n == 1 or n == 2:
        return 1
       if n not in memo:
            memo[n] = fibo(n-1) + fibo(n-2)
       return memo[n]



2. BOTTOM-UP

memo = {1: 1, 2: 1} # base 초기값 셋팅
def fibo(n):
    for i in range(3, n+1):
        memo[i] = memo[i-1] + memo[i-2]

    return memo[n]

