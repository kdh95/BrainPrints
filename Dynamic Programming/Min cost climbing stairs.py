# 계단을 올라가고 있다. 한 번 올라갈 때마다 1 step 또는 2 step 올라갈 수 있다.
# 문제에서 정수형 배열 cost가 주어지는데, cost[i]는 i번째 계단을 밟았을 때 지불해야 하는 비용이다.
#
# 처음 시작은 index 0  또는 index 1 중 한 곳에서 시작할 수 있다.한
#
# 이 계단의 꼭대기에 도착하기 위해 지불해야하는 비용의 최소값을 반환하라.
# (return the minimum cost to reach the top of the floor)
#
# 제약조건
# 2 <= cost.length <= 1000
# 0 <= cost.[i] <= 999
#
# input : cost = [10, 15, 20]
# output : 15
#
# input : cost = [1,100,1,1,1,100,1,1,100,1]
# output : 6


# 완전탐색으로 모두 확인해보면 되지 않을까?
# O(N^2) 으로 풀면 되겠다.


# 접근방법 (1)
# 완전탐색 : 모두 따져보고 비용이 가장 작은것을 return 하면 되지 않을까?
# 재귀를 이용해서 경우의 수를 모두 따져보자.
# 꼭대기에서 생각을 해보자. => 0,1,2층 과 꼭대기가 있으면 1칸, 2칸씩만 갈 수 있기 때문에 1층에서 2칸 움직여 꼭대기로 가거나,
# 2층에서 1칸 움직여 꼭대기로 가거나 2가지 경우이다. 그렇다면 2층과 1층을 가는 방법을 생각해보자
# 이런식으로 하위로 내려가며 값을 계산하여 최소값을 구할 수 있다.


# 코드 대략적으로 짜보면
# cost = [10, 15, 20, 17, 1]
# def dfs(n):
#      if n == 0 and n == 1:
#           return 0
#   return min(dfs(n-1) + cost[n-1],dfs(n-2) + cost[n-2])

# 이렇게 코드를 짜면 O(2^n) 이므로 시간초과가 난다.
# 그렇기 때문에 중복된 값을 메모리에 저장하고 가져다 써야겠다.


# cost = [10, 15, 20, 17, 1]
# def dfs(n):
#   return min(n-1층에서 올라오는거 vs n-2층에서 올라오는거)